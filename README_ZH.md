# snowflake
这是雪花算法的一个GO语言的实现。支持更灵活的生成方式。

## 目标：
1. 分布式环境下，生成的序列号不重复
2. 单机多线程，生成的序列号不重复
3. 单机性能足够好

## 实现方案：
为了实现目标，生成的序列号为一个64位的数字。这个数字的组成由以下几个部分：
* 机房
* 机器
* 时间
* 序列

机房和机器来实现多机情况下，每台机器都有唯一标识；

时间保证在单机的情况下，有序增长，避免重复；

序列保证在单位时间内递增

另外，程序要保证多进程的序列生成不重复
## 序列号解析：
序列号的二进制结构：
```go
0 0000 0000 0000000000000000000000000000000000000000 000000000000000
```
按空格分组：
* 第一组，固定为0，避免数据溢出，出现负值
* 第二组，长度不固定，需设置，机房的ID
* 第三组，长度不固定，需设置，机器的ID
* 第四组，长度38-42，按需设置，当前时间戳减固定时间戳的值
* 第四组，长度不固定，自动计算，当前时刻下的序列增长

## 安装
```shell
go get github.com/agclqq/snowflake
```
## 用例
```go
package main

import (
	"fmt"
	"github.com/agclqq/snowflake"
)

func main()  {
	sf,err:=snowflake.New(2,2,2,2,snowflake.T38)
	if err!=nil{
		fmt.Println(err)
		return
	}
	id:=sf.GetId()
	fmt.Println(id)
}
```

## 最佳实践
**效率**

通过测试用例中的 TestSnowFlake_simg_GetId()方法，通过调整`New()的参数`和程序中`num变量`的值，可以测一下每秒可达到的num值，来确认你理想的性能。

在本测试用例中，`Intel(R) Core(TM) i7-10750H CPU @ 2.60GHz`的硬件环境下，达到每秒可生产约240万个序列号。

**多端冲突**

如果你的终端的信息不可控，如在k8s pod中部署，可以采用datacenter和machine使用随机数的办法来解决冲突。当随机的数位达到合理的长度时，冲突的概率也会大大降低。

在测试用例TestSnowFlake_GetRandomI()中，冲突的概率约为90万分之一

